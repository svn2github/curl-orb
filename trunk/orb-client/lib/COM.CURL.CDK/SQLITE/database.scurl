||| Copyright (C) 1998-2009, Sumisho Computer Systems Corp.  All Rights Reserved.
|||
||| An OpenCurl project.

||| Licensed under the Apache License, Version 2.0 (the "License");
||| you may not use this file except in compliance with the License.
||| You may obtain a copy of the License at
||| 
|||     http://www.apache.org/licenses/LICENSE-2.0
||| 
||| Unless required by applicable law or agreed to in writing, software
||| distributed under the License is distributed on an "AS IS" BASIS,
||| WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
||| See the License for the specific language governing permissions and
||| limitations under the License.

{doc-next
    {purpose
        An object representing a SQLite database connection.
    }
    {notes
        The connection will be closed when an applet is suspended,
        but all state will be re-installed when the applet is
        resumed.
    }
}
{define-class public open SQLiteDatabase {inherits EventTarget}

  field private _handle:SQLiteDatabaseHandle

  {doc-next
    {purpose
        If non-{ctext null}, this is the {docref Url} of the database to
        connect to. If null then the database will be a memory
        database.
    }
  }
  {getter public {url}:#Url
    {return self._handle.url}
  }


  {doc-next
    {purpose
        Constructs a {ctext SQLiteDatabase} object.
    }
    {parameter u,
        The {docref Url} of the database to connect to.

        If {param u} is {ctext null} then a memory database connection
        is opened. If {param u} is not a local file {docref Url}, the
        file will be downloaded and copied to a local file.  An error
        will be thrown if {param u} is not a local file {docref Url},
        and it does not exist.  If {param u} is a local file {docref Url},
        but it does not exist, it will be created, however the parent
        directory of {param u} must already exist.
    }
    {parameter read-only?,
        If {ctext true} open the database for reading only.
    }
    {parameter error-if-missing?,
        If {ctext true} fail to open if the file does not already exist,
        if {ctext false} create the file if it does not already exist.
        This is implicitly {ctext true} if {param read-only?} is {ctext true}.
    }
    {parameter auto-vacuum?,
        Should the database remove unused space when ever an operation
        that writes to the database occurs.
        This only effects newly created database files.
    }
    {parameter page-size,
        The size of pages for the database to use, this should be a
        power of 2, and there is an upper limit compiled into the SQLite
        engine.  This only effects newly created database files.  If
        this is -1, then the default built into SQLite will be used.
    }
    {parameter encryption-type,
        Type of encryption to use for an encrypted database.
    }
    {parameter key,
        Key to use for an encrypted database.  {ctext null} or an empty
        array are equivilent to no encryption.
    }
    {parameter commit-events?,
        Should {docref SQLiteCommitEvent}s get sent to any
        event handlers that are supplied in {param ...} that
        subscribe to those?  If {ctext true} a handler will be
        installed for {docref SQLiteDatabase.commit-hook} which
        will be overwritten if {docref SQLiteDatabase.commit-hook}
        is changed.
    }
    {parameter rollback-events?,
        Should {docref SQLiteRollbackEvent}s get sent to any
        event handlers that are supplied in {param ...} that
        subscribe to those?  If {ctext true} a handler will be
        installed for {docref SQLiteDatabase.rollback-hook} which
        will be overwritten if {docref SQLiteDatabase.rollback-hook}
        is changed.
    }
    {parameter update-events?,
        Should {docref SQLiteUpdateEvent}s get sent to any
        event handlers that are supplied in {param ...} that
        subscribe to those?  If {ctext true} a handler will be
        installed for {docref SQLiteDatabase.update-hook} which
        will be overwritten if {docref SQLiteDatabase.update-hook}
        is changed.
    }
    {parameter ...,
        Event handlers to receive various subclasses of {docref SQLiteEvent}
        as indicated by the values supplied in {param commit-events?},
        {param rollback-events?} and {param update-events?}.
    }
    {notes
        The database connection will not be opened till an attempt is
        made to use it.
    }
    {details
        The following PRAGMAs are run on each database connection which
        will change the defaults from what SQLite normally does.
        {ctext "PRAGMA encoding='UTF-8'; PRAGMA synchronous=NORMAL"}
    }
  }
  || TODO: Should we make an implicit constructor from #Url?
  {constructor public {default
                          u:#Url,
                          error-if-missing?:bool = false,
                          read-only?:bool = false,
                          auto-vacuum?:bool = false,
                          page-size:int = -1,
                          encryption-type:SQLiteEncryptionType =
                              SQLiteEncryptionType.none,
                          key:#ByteArray = null,
                          commit-events?:bool = false,
                          rollback-events?:bool = false,
                          update-events?:bool = false,
                          ...:EventHandler
                      }
    {if-non-null nn-u = u then
        {if nn-u.local-filename == null then
            || must be http(s)
            set u = {local-data-copy-of nn-u, "SQLITEDB", force-copy? = true}
        }
    }
    set self._handle =
        {SQLiteDatabaseHandle 
            u,
            error-if-missing? = error-if-missing?,
            read-only? = read-only?,
            auto-vacuum? = auto-vacuum?,
            page-size = page-size,
            encryption-type = encryption-type,
            key = key
        }

    || Notification
    set self.commit-events? = commit-events?
    set self.rollback-events? = rollback-events?
    set self.update-events? = update-events?
    
    {for eh in ... do
        {self.add-event-handler eh}
    }
  }

  {doc-next
    {purpose
        Throws a {docref SQLiteException} if the most recent SQLite
        API call failed.
    }
    {notes
        Calling this method does nothing if the database connection is
        closed.
    }
  }
  {method public open {check-status}:void
    {if not self._handle.open? then {return}}
        
    let constant interface:SQLiteInterface = {SQLiteInterface}
    let constant code:SQLiteStatus = {interface.errcode self._handle}
    {if not {SQLiteStatus-ok? code} then
        {throw {SQLiteException code, {interface.errmsg self._handle}}}
    }
  }

  {doc-next
    {purpose
        Executes one or more SQL statements.
    }
    {parameter sql,
        The SQL statement or statements to be executed.
    }
    {parameter callback,
        The callback function that will be called once for each row of
        the query result.

        The {param callback} should normally return {ctext false}. If it
        returns {ctext true} then the query is aborted and all
        subsequent SQL statements are skipped and then this function
        will then return {ctext SQLiteStatus.ABORT}.

        The first argument is the values of the row and the second
        argument is the names the columns.
    }
    {parameter throw-on-error?,
        If {ctext true} and executing the {ctext sql} statement fails,
        an error will be thrown. Otherwise no error will be thrown and
        the caller is responsible to check the return value of this
        method to see if the {param sql} statement was successfully
        executed or not.

        It is {ctext true} by default.
    }
    {return-vals
        If all the SQL commands, {param sql} succeed, the return value
        is {ctext SQLiteStatus.OK}, otherwise it is an error
        code. The particular return value depends on the type of
        error. If the query could not be executed because a table
        is locked, then this function returns {ctext
        SQLiteStatus.BUSY}.
    }
    {notes
        Calling this method will open the database connection if it is
        not open.
    }
  }
  {method public open {execute
                          sql:StringInterface,
                          callback:#{proc-type
                                        {data:StringArray,
                                         column-names:StringArray
                                        }:bool
                                    } = null,
                          throw-on-error?:bool = true
                      }:SQLiteStatus
    || Note: this re-implements sqlite3_exec to get our try/finally
    || blocks around all of the execution, since that makes sure that
    || no throwing or bugs in sqlite3_exec can leave stranded
    || unfinalized statements.
    let status:SQLiteStatus = SQLiteStatus.OK
    {with-statement in self
        stmt = {sql.to-String}
     do
        {while true do
            set status =
                {stmt.step throw-on-error? = throw-on-error?}
            {if status == SQLiteStatus.ROW then
                {if-non-null callback then
                    let count:int = stmt.column-count
                    let current-row:StringArray =
                        {StringArray efficient-size = count}
                    {for i = 0 below count do
                        {current-row.append
                            {if-non-null s = {stmt.get-column-text i} then
                                s
                             else
                                ""
                            }
                        }
                    }
                    {if {callback current-row, stmt.column-names} then
                        {return SQLiteStatus.ABORT}
                    }
                }
             elseif status == SQLiteStatus.DONE then
                let not-done?:bool
                set (not-done?, status) =
                    {stmt.prepare-next throw-on-error? = throw-on-error?}
                {if not not-done? then
                    {return SQLiteStatus.OK}
                 elseif status != SQLiteStatus.OK then
                    {return status}
                }
                
             elseif status != SQLiteStatus.OK then
                {break}
            }
        }
    }
    {return {if {SQLiteStatus-ok? status} then SQLiteStatus.OK else status}}
  }

  {doc-next
    {purpose
        Registers a callback function that may be invoked whenever an
        attempt is made to open a table that another thread
        or process has locked.
    }
    {parameter callback,
        The callback procedure.
        
        It has one argument, which is
        the number of prior calls to the {param callback} for the same
        lock.

        If the callback returns {ctext false}, then no additional attempts are
        made to access the table, and the blocked API call will
        return {ctext SQLiteStatus.BUSY}. If it returns {ctext true} then
        another attempt is made by the API function to access the table,
        and the cycle repeats itself.

        If the {param callback} argument is set to {ctext null}, then
        this will effectively remove the callback function, if one was
        previously registered.
    }
    {details
        If a callback function is registered, SQLite may call it
        rather than the SQLite methods returning {ctext
        SQLiteStatus.BUSY}.

        The presence of a busy handler does not guarantee that it will
        be invoked whenever there is a lock contention. If SQLite
        determines that invoking the busy handler could result in a
        deadlock, it will return {ctext SQLiteStatus.BUSY} instead.
    }
    {notes
        This replaces the implicit busy handler set with
        {docref SQLiteDatabase.busy-timeout}.
    }
    {notes
        The supplied procedure must not modify the {docref SQLiteDatabase}
        in any way, including creating {docref SQLiteStatement}s, calling
        {docref SQLiteStatement.step} or calling
        {docref SQLiteDatabase.close}.
    }
  }
  {getter public open {busy-handler}:#SQLiteBusyHandlerProcType
    {return self._handle.busy-handler}
  }
  {setter public open {busy-handler
                          callback:#SQLiteBusyHandlerProcType
                      }:void
    let (status:SQLiteStatus, errmsg:#String) =
        {self._handle.set-busy-handler callback}
    {if status != SQLiteStatus.OK then
        {throw {SQLiteException status, {non-null errmsg}}}
    }
  }

  {doc-next
    {purpose
        Sets the busy time out.
    }
    {parameter ms,
        The least time that will cause calls that can not complete due
        to competing table locks to fail with {ctext SQLiteStatus.BUSY}.

        If {param ms} is non-positive it will turn off all the busy
        handlers.
    }
    {return-vals
        On success it returns {ctext SQLiteStatus.OK} otherwise it
        will return an error {docref SQLiteStatus} code.
    }
    {notes
        Setting this replaces any busy handler set with
        {docref SQLiteDatabase.busy-handler}.

        By default a {docref SQLiteDatabase} has
        {docref SQLiteDatabase.busy-timeout} set to {ctext 5s}.
    }
  }
  {getter public {busy-timeout}:Time
    {return self._handle.busy-timeout}
  }
  {setter public {busy-timeout t:Time}:void
    let (status:SQLiteStatus, errmsg:#String) =
        {self._handle.set-busy-timeout t}
    {if status != SQLiteStatus.OK then
        {throw {SQLiteException status, {non-null errmsg}}}
    }
  }

  {doc-next
    {purpose
        Registers a callback function on the database connection that
        will be invoked whenever a row is updated, inserted, or deleted.
    }
    {parameter callback,
        The callback procedure.

        The first argument is {ctext SQLiteOperation.INSERT},
        {ctext SQLiteOperation.DELETE} or {ctext
        SQLiteOperation.UPDATE}, depending on the operation that
        caused the callback to be invoked.

        The second and third arguments identify the database and the
        table name containing the effected row and the final callback
        argument is the {ctext ROWID} of the row. In case of an
        update, this is the {ctext ROWID} after the update takes
        place.
    }
    {details
        The {param callback} is not invoked when internal system
        tables are modified.

        See also {docref SQLiteDatabase.commit-hook} and {docref
        SQLiteDatabase.rollback-hook}.
    }
    {notes
        The supplied procedure must not modify the {docref SQLiteDatabase}
        in any way, including creating {docref SQLiteStatement}s, calling
        {docref SQLiteStatement.step} or calling
        {docref SQLiteDatabase.close}.
    }
  }
  {setter public open {update-hook
                          callback:#SQLiteUpdateHookProcType
                      }:void
    set self._handle.update-hook = callback
  }

  {getter public open {update-hook}:#SQLiteUpdateHookProcType
    {return self._handle.update-hook}
  }

  {doc-next
    {purpose
        Registers a callback function with the database connection that
        will be invoked whenever a new transaction is completed.
    }
    {parameter callback,
        The callback procedure.
    }
    {notes
        If {param callback} returns {ctext true} then the commit is
        converted into a rollback.
    }
    {notes
        The supplied procedure must not modify the {docref SQLiteDatabase}
        in any way, including creating {docref SQLiteStatement}s, calling
        {docref SQLiteStatement.step} or calling
        {docref SQLiteDatabase.close}.
    }
  }
  {setter public open {commit-hook
                          callback:#SQLiteCommitHookProcType
                      }:void
    set self._handle.commit-hook = callback
  }

  {getter public open {commit-hook}:#SQLiteCommitHookProcType
    {return self._handle.commit-hook}
  }

  {doc-next
    {purpose
        Registers a callback function with the database connection that
        will be invoked whenever a transaction is rolled back.
    }
    {parameter callback,
        The callback procedure.
    }
    {notes
        The {param callback} will be invoked if an explicit {ctext
        ROLLBACK} statement is executed, or an error or constraint
        causes an implicit rollback to occur. It will not be invoked
        if a transaction is automatically rolled back because the
        database connection is closed.
    }
    {notes
        The supplied procedure must not modify the {docref SQLiteDatabase}
        in any way, including creating {docref SQLiteStatement}s, calling
        {docref SQLiteStatement.step} or calling
        {docref SQLiteDatabase.close}.
    }
  }
  {setter public open {rollback-hook
                          callback:#SQLiteRollbackHookProcType
                     }:void

    set self._handle.rollback-hook = callback
  }

  {getter public open {rollback-hook}:#SQLiteRollbackHookProcType
    {return self._handle.rollback-hook}
  }

  {doc-next
    {purpose
        Set the progress handler that will get called periodically
        when executing a statement takes more than {param instruction-count}
        instructions.
    }
    {parameter instruction-count,
        Number of instructions that must be executed before calling
        {param callback}.
    }
    {parameter callback,
        The callback procedure.
    }
    {notes
        The {param callback} may not be invoked for all statements, if
        the statement takes less than {param instruction-count} instructions
        to complete.  If the {param callback} returns {ctext true}
        then the executing statement will be terminated.

        Providing a {ctext null} {param callback} will uninstall the
        progress handler.
    }
    {notes
        The supplied procedure must not modify the {docref SQLiteDatabase}
        in any way, including creating {docref SQLiteStatement}s, calling
        {docref SQLiteStatement.step} or calling
        {docref SQLiteDatabase.close}.
    }
  }
  {method public {set-progress-handler
                     instruction-count:int,
                     callback:#SQLiteProgressHandlerProcType
                 }:void
    {self._handle.set-progress-handler instruction-count, callback}
  }

  {doc-next
    {purpose
        Registers a callback function with the database connection that
        will be invoked whenever a statement is prepared.
    }
    {parameter callback,
        The callback procedure.
    }
    {notes
        The {param callback} can return {ctext SQLiteAuthorizerReturnCode.OK}
        to allow an statement to proceed,
        {ctext SQLiteAuthorizerReturnCode.DENY} to fail a statement,
        or when the operation is {ctext SQLiteOperation.READ},
        it can return {ctext SQLiteAuthorizerReturnCode.IGNORE} to
        disallow access to a particular table column.

        The first parameter to {param callback} is the {docref SQLiteOperation}         describing the operation being considered, and the next 4 arguments
        provide various information depending on the operation.
        The second argument is usually the name of the entity being operated
        on, and the third argument is the name of the other entity being
        operated on, if appropriate.  The fourth argument is usually the
        database name, and the fifth argument is the name of the inner-most
        trigger or view if there is one.

        Setting {param callback} to {ctext null} will uninstall any
        authorizer callback.
    }
    {notes
        The supplied procedure must not modify the {docref SQLiteDatabase}
        in any way, including creating {docref SQLiteStatement}s, calling
        {docref SQLiteStatement.step} or calling
        {docref SQLiteDatabase.close}.
    }
  }
  {setter public {authorizer
                     callback:#SQLiteAuthorizerProcType
                 }:void
    let (status:SQLiteStatus, errmsg:#String) =
        {self._handle.set-authorizer callback}
    {if status != SQLiteStatus.OK then
        {throw {SQLiteException status, {non-null errmsg}}}
    }
  }

  {getter public {authorizer}:#SQLiteAuthorizerProcType
    {return self._handle.authorizer}
  }

  {doc-next
    {purpose
        Interrupt an executing operation.
    }
    {notes
        Normally called from a callback of some sort.
    }
  }
  {method public {interrupt}:void
    {if self._handle.open? then
        {{SQLiteInterface}.interrupt self._handle}
    }
  }

  {doc-next
    {purpose
        Returns the number of database rows that were updated,
        inserted or deleted, by the most recently completed {ctext
        UPDATE}, {ctext INSERT} or a {ctext DELETE} statement.
    }
    {notes
        Only changes that are directly specified by the {ctext
        UPDATE}, {ctext INSERT} or {ctext DELETE} statement are
        counted. Auxiliary changes caused by the triggers are not
        counted.

        If it is called within a trigger, it reports the number of
        rows that where changed for the most recently completed {ctext
        UPDATE}, {ctext INSERT} or {ctext DELETE} statement within
        that trigger.

        SQLite implements the command {ctext DELETE FROM table},
        without a where clause, by dropping and recreating the
        table. Because of this optimization, the change count for
        {ctext DELETE FROM table} will be zero regardless of the
        number of records that were originally in the table. To obtain
        the actual number of rows deleted, use {ctext DELETE FROM
        table WHERE 1} instead, which disables the optimization.

        If the database connection is not open, this method will
        return 0.

        See also: {docref SQLiteDatabase.total-changes}.
    }
  }
  {getter public open {changes}:int
    {if not self._handle.open? then {return 0}}

    {return {{SQLiteInterface}.changes self._handle}}
  }

  {doc-next
    {purpose
        Returns the total number of database rows that were modified,
        inserted or deleted, since the database connection was created.
    }
    {notes
        All changes are counted, including changes by triggers and
        changes to temp and auxiliary databases. Changes on
        internal tables, caused by statements
        such as {ctext CREATE TABLE} are not counted. Changes counted
        when an entire table is deleted using {ctext DROP TABLE} are
        not counted either.

        SQLite implements the command {ctext DELETE FROM table},
        without a where clause, by dropping and recreating the
        table. Because of this optimization, the change count for
        {ctext DELETE FROM table} will be zero regardless of the
        number of records that were originally in the table. To obtain
        the actual number of rows deleted, use {ctext DELETE FROM
        table WHERE 1} instead, which disables the optimization.

        If the database connection is not open, this method will
        return 0.

        See also: {docref SQLiteDatabase.changes}.
    }
  }
  {getter public open {total-changes}:int
    {if not self._handle.open? then {return 0}}
    {return {{SQLiteInterface}.total-changes self._handle}}
  }

  {doc-next
    {purpose
        Returns the auto-increment primary key value generated from the
        last successful {ctext INSERT} statement.
    }
    {return-vals
        The primary key value.
    }
    {notes
        Each entry in a SQLite table has a unique integer key. The key
        is the value of the {ctext INTEGER PRIMARY KEY} column if
        there is such a column, otherwise the key is generated at
        random. The unique key is always available as the {ctext
        ROWID}, {ctext OID}, OR {ctext _ROWID_}.

        It is an error to call this method on a closed database
        connection.
    }
  }
  {getter public open {last-insert-rowid}:int64
    {return {{SQLiteInterface}.last-insert-rowid self._handle}}
  }

  {doc-next
    {purpose
        Returns the error code for the most recently failed SQLite API
        call with respect to this database.
    }
    {return-vals
        The error code from the most recently failed API call
        associated with object.
    }
    {notes
        If a prior API call fails but the most recent API call
        succeeds, the return value from this function is undefined.

        It the database connection is not open, this method will
        return {ctext SQLiteStatus.OK}.
    }
  }
  {getter public open {errcode}:SQLiteStatus
    {if not self._handle.open? then {return SQLiteStatus.OK}}

    {return {{SQLiteInterface}.errcode self._handle}}
  }

  {doc-next
    {purpose
        Returns the error message as a {docref String} for the most
        recently failed SQLite API call with respect to this database.
    }
    {return-vals
        Error message in {ctext English} for the most recently failed
        API call associated with this object.
    }
    {notes
        The message {ctext not an error} is returned when the most
        recent API call is successful.

        It is an error to call this method on a closed database
        connection.
    }
  }
  {getter public open {errmsg}:String
    {return {{SQLiteInterface}.errmsg self._handle}}
  }
  
  || info
  || -----------
  {doc-next
    {purpose
        The version of the SQLite library as a number.
    }
    {details
        If a version number looks like X.Y.Z then this number will be
        X*1000000 + Y*1000 + Z.
    }
  }
  {getter public {version}:int
    {return {{SQLiteInterface}.libversion-number}}
  }

  {doc-next
    {purpose
        The version of the SQLite library as a {docref String}.
    }
  }
  {getter public {version-string}:String
    {return {{SQLiteInterface}.libversion}}
  }

  {doc-next
    {purpose
        Adds SQL function or redefines the behavior of an existing
        SQL function or an aggregate.
    }
    {parameter name,
        Name to use in SQL for the function.
    }
    {parameter number-of-args,
        Number of arguments that the function will take.
        If negative, then the the function can take any number of arguments.
        You can have multiple functions registered with the same name if
        they are installed with a different {param number-of-args}.
    }
    {parameter xfunc,
        For a scalar function this will be called with the appropriate
        number of arguments, of the types supplied by SQLite, and it
        should return the value to be used as the result in SQLite.

        For an aggregate function this will get a 'context' value as
        the first argument, and the first time that the aggregate
        function is called, it will be the {ctext initialized-value}
        of the type of the first argument to this function.  And the
        function should return a value for the 'context' that will be
        saved and passed in for the next item.
    }
    {parameter xfunc-final,
        If {param xfunc} is an aggregate function, then this parameter
        must be supplied to produce the final value.  The only parameter
        will be the 'context' value, and it should return the value to
        be used as the result in SQLite.
    }
    {notes
        If one of the functions throws an {docref Exception} then the
        {docref Exception.message} will be set as the error message, and
        the function will be marked as failing.  If the {docref Exception}
        is a {docref SQLiteException} then {docref SQLiteException.code}
        will be set as the error code, if the exception is not a 
        {docref SQLiteException}, then the error code will be
        {docref SQLiteStatus.ERROR}.
    }
    {notes
        Functions must not call {docref SQLiteStatement.finalize} or 
        {docref SQLiteStatement.reset} on the statement that is currently
        executing the function.  And they must not call
        {docref SQLiteDatabase.close} on the {docref SQLiteDatabase} that
        they are installed on.
    }
  }
  {method public {install-function
                     name:String,
                     number-of-args:int,
                     xfunc:any,
                     final-xfunc:any = null
                 }:void
    let (status:SQLiteStatus, errmsg:#String) =
        {self._handle.install-function
            name, number-of-args, xfunc, final-xfunc = final-xfunc
        }
    {if status != SQLiteStatus.OK then
        {throw {SQLiteException status, {non-null errmsg}}}
    }
  }

  {doc-next
    {purpose
        Uninstalls a previously installed function, installed with the
        same {param name} and {param number-of-args}, if any.
    }
    {parameter name,
        Name of the function to uninstall.
    }
    {parameter number-of-args,
        Number of arguments that function took.
    }
  }
  {method public {uninstall-function
                     name:String,
                     number-of-args:int
                 }:void
    let (status:SQLiteStatus, errmsg:#String) =
        {self._handle.uninstall-function name, number-of-args}
    {if status != SQLiteStatus.OK then
        {throw {SQLiteException status, {non-null errmsg}}}
    }
  }

  {method package {prepare-statement
                      sql:String,
                      stmt:SQLiteStatementHandle,
                      throw-on-error?:bool
                  }:(tail:#String, SQLiteStatus)
    let (tail:#String, status:SQLiteStatus, errmsg:#String) =
        {self._handle.prepare-statement sql, stmt}
    {if throw-on-error? and status != SQLiteStatus.OK then
        {throw {SQLiteException status, {non-null errmsg}}}
    }
    {return tail, status}
  }

  {method package {finalize-statement
                      stmt:SQLiteStatementHandle
                  }:SQLiteStatus
    {return {self._handle.finalize-statement stmt}}
  }

  || statement convenience functions
  || --------------------
  
  {doc-next
    {purpose
        Create a prepared SQLite statement.
    }
  }
  {method public {create-statement sql:StringInterface}:SQLiteStatement
    {return {SQLiteStatement self, sql}}
  }

  || SQL convenience functions
  || --------------------

  {doc-next
    {purpose
        Return whether specified SQL query returns any data.
    }
    {parameter sql, the SQL query}
    {parameter ..., rest args are used as parameters for the query
        (using {docref SQLiteStatement.bind}).}
    {return-vals
        If any rows are selected by the query, returns {ctext true}.
    }
  }
  {method public {sql-exists?
                     sql:StringInterface,
                     ...:any
                 }:bool
    {return
        {with-statement in self s = sql do
            {s.bind {splice ...}}
            {s.data-exists?}
        }}
  }

  {doc-next
    {purpose
        Return one value from the first row
        returned by the specified SQL query.
    }
    {parameter sql, the SQL query}
    {parameter index, specifies which column.}
    {parameter ..., rest args are used as parameters for the query
        (using {docref SQLiteStatement.bind}).}
    {return-vals
        The value of the specified column for the first row,
        or null if no rows are selected by the query.
    }
  }
  
  {method public {sql-value
                     sql:StringInterface,
                     index:int = 0,
                     ...
                 }:any
    {return
        {with-statement in self s = sql do
            {s.bind ...}
            {s.data-value index = index}
        }}
  }  

  {doc-next
    {purpose
        Return the values in a column 
        returned by the specified SQL query.
    }
    {parameter sql, the SQL query}
    {parameter index, specifies which column.}
    {parameter ..., rest args are used as parameters for the query
        (using {docref SQLiteStatement.bind}).}
    {return-vals
        An array of values.
    }
  }

  {method public {sql-column
                     sql:StringInterface,
                     index:int = 0,
                     ...
                 }:Array
    {return
        {with-statement in self s = sql do
            {s.bind {splice ...}}
            {s.data-column index = index}
        }}
  }

  {doc-next
    {purpose
        Return the values in the first row
        returned by the specified SQL query.
    }
    {parameter sql, the SQL query}
    {parameter ..., rest args are used as parameters for the query
        (using {docref SQLiteStatement.bind}).}
    {return-vals
        An array of values.
        These will be undefined if there is no data.
    }
  }

  {method public {sql-row
                     sql:StringInterface,
                     ...
                 }:Array
    {return
        {with-statement in self s = sql do
            {s.bind {splice ...}}
            {s.data-row}
        }}
  }

  {doc-next
    {purpose
        Return the values in each row
        returned by the specified SQL query.
    }
    {parameter sql, the SQL query}
    {parameter ..., rest args are used as parameters for the query
        (using {docref SQLiteStatement.bind}).}
    {return-vals
        An array of rows.
    }
  }
  
  {method public {sql-rows
                     sql:StringInterface,
                     ...
                 }:{Array-of Array}
    {return
        {with-statement in self s = sql do
            {s.bind {splice ...}}
            {s.data-rows}
        }}
  }
  
  field private _commit-events?:bool
  {getter public {commit-events?}:bool
    {return self._commit-events?}
  }
  {setter public {commit-events? val:bool}:void
    {if val != self._commit-events? then
        set self._commit-events? = val
        set self.commit-hook =
            {if val then 
                {proc {}:bool
                    let e:SQLiteCommitEvent = {SQLiteCommitEvent}
                    {self.handle-event e}
                    {return e.consumed?}
                }
             else 
                null
            }
    }
  }

  field private _rollback-events?:bool
  {getter public {rollback-events?}:bool
    {return self._rollback-events?}
  }
  {setter public {rollback-events? val:bool}:void
    {if val != self._rollback-events? then
        set self._rollback-events? = val
        set self.rollback-hook = 
            {if val then 
                {proc {}:void
                    {self.handle-event {SQLiteRollbackEvent}}
                }
             else 
                null
            }
    }
  }

  field private _update-events?:bool
  {getter public {update-events?}:bool
    {return self._update-events?}
  }
  {setter public {update-events? val:bool}:void
    {if val != self._update-events? then
        set self._update-events? = val
        set self.update-hook =
            {if val then 
                {proc {operation:SQLiteOperation,
                       database-name:String,
                       table-name:String,
                       rowid:int64
                       }:void
                    {self.handle-event
                        {SQLiteUpdateEvent
                            database-name, table-name, operation, rowid}
                    }
                }
             else 
                null
            }
    }
  }

  {doc-next
    {purpose
        Attach a new database under the supplied {param name}.
    }
    {parameter u,
        {docref Url} of the database to attach.
    }
    {parameter name,
        Name to use in subsequent SQL queries to access tables in the
        database in {param u}.
    }
    {parameter encryption-type,
        Type of encryption to use for an encrypted database.
    }
    {parameter key,
        Key to use for an encrypted database.  {ctext null} or an empty
        array are equivilent to no encryption.
    }
  }
  {method public {attach u:Url, name:String,
                     encryption-type:SQLiteEncryptionType =
                         SQLiteEncryptionType.none,
                     key:#ByteArray = null
                 }:void
    {if u.local-filename == null then
        || must be http(s)
        set u = {local-data-copy-of u, "SQLITEDB", force-copy? = true}
    }
    let (status:SQLiteStatus, errmsg:#String) =
        {self._handle.attach
            u, name, encryption-type = encryption-type, key = key
        }
    {if status != SQLiteStatus.OK then
        {throw {SQLiteException status, {non-null errmsg}}}
    }
  }

  {doc-next
    {purpose
        Detach a previously attached database.
    }
    {parameter name,
        Name supplied when the database was attached.
    }
  }
  {method public {detach name:String}:void
    let (status:SQLiteStatus, errmsg:#String) = {self._handle.detach name}
    {if status != SQLiteStatus.OK then
        {throw {SQLiteException status, {non-null errmsg}}}
    }
  }

  {method public {open}:void
    let (status:SQLiteStatus, errmsg:#String) = {self._handle.open}
    {if status != SQLiteStatus.OK then
        {throw {SQLiteException status, {non-null errmsg}}}
    }
  }

  {method public {close}:void
    let (status:SQLiteStatus, errmsg:#String) = {self._handle.close}
    {if status != SQLiteStatus.OK then
        {throw {SQLiteException status, {non-null errmsg}}}
    }
  }

  {doc-next
    {purpose
        Re-encrypt the database with a new key.
    }
    {parameter encryption-type,
        Type of encryption to use for an encrypted database.
    }
    {parameter key,
        Key to use for an encrypted database.  {ctext null} or an empty
        array are equivilent to no encryption.
    }
  }
  {method public {rekey
                     encryption-type:SQLiteEncryptionType, key:#ByteArray
                 }:void
    let status:SQLiteStatus =
        {{SQLiteInterface}.rekey self._handle, encryption-type, key}
    {if status != SQLiteStatus.OK then
        let errmsg:String =
            {if status == SQLiteStatus.CURL-INTERNAL-MISSING-API then
                set status = SQLiteStatus.AUTH
                {lmessage Authentication APIs are not available.}
             else
                {{SQLiteInterface}.errmsg self._handle}
            }
        {throw {SQLiteException status, errmsg}}
    }
  }

  {doc-next
    {purpose
        Set the encryption key for the main database.
    }
    {parameter encryption-type,
        Type of encryption to use for an encrypted database.
    }
    {parameter key,
        Key to use for an encrypted database.  {ctext null} or an empty
        array are equivilent to no encryption.
    }
    {notes
        This may not do anything if reading or writing to the
        {docref SQLiteDatabase} has already been attempted.
    }
  }
  {method public {set-key 
                     encryption-type:SQLiteEncryptionType, key:#ByteArray
                 }:void
    let (status:SQLiteStatus, errmsg:#String) =
        {self._handle.set-key encryption-type, key}
    {if status != SQLiteStatus.OK then
        {throw
            {SQLiteException status, errmsg}
        }
    }
  }

 {doc-next
    {purpose
        Provide information about a column in a table.
    }
    {parameter database-name,
        Name of the database to look for the table in.  If {ctext null}
        search all attached databases for the table.
    }
    {parameter table-name,
        Name of the table to look for the column in.
    }
    {parameter column-name,
        Name of the column to get metadata for.
    }
    {notes
        This may return a {ctext auto-increment?} of {ctext false} for columns
        which are an alias for the {ctext ROWID}, even though the
        {ctext ROWID} is basically auto-increment.
    }
  }
  {method public {table-column-metadata
                     database-name:#String,
                     table-name:String,
                     column-name:String
                 }:(datatype:#String, collation:#String,
                    not-null?:bool, primary-key?:bool, auto-increment?:bool)
    def (status, datatype, collation, not-null?, primary-key?, auto-increment?) =
        {{SQLiteInterface}.table-column-metadata
            self._handle,
            {if database-name == "" then "main" else database-name},
            table-name,
            column-name
        }
    {if status != SQLiteStatus.OK then
        let errmsg:String =
            {if status == SQLiteStatus.CURL-INTERNAL-MISSING-API then
                {lmessage Metadata APIs are not available.}
             else
                {{SQLiteInterface}.errmsg self._handle}
            }
        {throw
            {SQLiteException status, errmsg}
        }
    }
    {return datatype, collation, not-null?, primary-key?, auto-increment?}
  }
}
