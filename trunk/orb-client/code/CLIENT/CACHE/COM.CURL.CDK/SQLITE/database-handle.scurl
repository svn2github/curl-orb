||| Copyright (C) 1998-2009, Sumisho Computer Systems Corp.  All Rights Reserved.
|||
||| An OpenCurl project.

||| Licensed under the Apache License, Version 2.0 (the "License");
||| you may not use this file except in compliance with the License.
||| You may obtain a copy of the License at
||| 
|||     http://www.apache.org/licenses/LICENSE-2.0
||| 
||| Unless required by applicable law or agreed to in writing, software
||| distributed under the License is distributed on an "AS IS" BASIS,
||| WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
||| See the License for the specific language governing permissions and
||| limitations under the License.

{define-class package final FunctionSpec
  field constant package name:String
  field constant package number-of-args:int
  field constant package xfunc:#SQLiteFunctionProcType
  field constant package xfunc-ptr:SQLiteFunctionPointerType
  field constant package final-xfunc:#SQLiteFinalFunctionProcType
  field constant package final-xfunc-ptr:SQLiteFinalFunctionPointerType

  {doc-next
    {purpose
        Constructs a {docref FunctionSpec} object.
    }
    {parameter name,
        The name of the function.

        The length of {param name} should be limited to {ctext 255} bytes, 
        exclusive of the zero-terminator. Note that the name length 
        limit is in bytes, not characters. Any attempt to create a 
        function with a longer name will result in an error.
    }
    {parameter number-of-args,
        The number of arguments that the SQL function takes. If this
        parameter is negative, then the SQL function may take any
        number of arguments.
    }
    {parameter xfunc,
        A function that implements the SQL function.
    }
    {parameter final-xfunc,
        A final function that implements the final part of a SQL final function.
    }
  }
  {constructor package {default
                           name:String,
                           number-of-args:int,
                           xfunc:#SQLiteFunctionProcType,
                           xfunc-ptr:SQLiteFunctionPointerType,
                           final-xfunc:#SQLiteFinalFunctionProcType = null,
                           final-xfunc-ptr:SQLiteFinalFunctionPointerType =
                               {uninitialized-value-for-type SQLiteFinalFunctionPointerType}
                       }
    set self.name = name
    set self.number-of-args = number-of-args
    set self.xfunc = xfunc
    set self.xfunc-ptr = xfunc-ptr
    set self.final-xfunc = final-xfunc
    set self.final-xfunc-ptr = final-xfunc-ptr
  }
}


{doc-next
    {purpose
        Opaque class to hold a handle to a SQLite statement, used
        when making statement related calls to {docref SQLiteDatabaseHandle}
        and {docref SQLiteInterface}.
    }
    {since 7.0}
}
{define-class public final SQLiteStatementHandle
  field package _handle:LowSQLiteStatementHandle
  field private _lock-out?:bool
  {constructor public {default}
    set self._handle = 0
  }
  {getter public {open?}:bool
    {return self._handle != 0}
  }
  {method private inline {check-lock-out}:void
    {if self._lock-out? then
        {throw
            {SQLiteException 
                SQLiteStatus.MISUSE,
                {hlmessage Can not call step, reset, or finalize while executing
                    a statement.}
            }
        }
    }
  }
  {method package {finalize}:SQLiteStatus
    {self.check-lock-out}
    {with self._lock-out? = true do
        let constant status:SQLiteStatus =
            {{SQLiteInterface}.finalize self._handle}
        set self._handle = 0
        {return status}
    }
  }

  {doc-next
    {purpose
        Executes a prepared query.
    }
    {return-vals
        The return value is either {ctext SQLiteStatus.BUSY}, {ctext
        SQLiteStatus.DONE}, {ctext SQLiteStatus.ROW}, {ctext
        SQLiteStatus.ERROR} or
        {ctext SQLiteStatus.MISUSE}.

        {ctext SQLiteStatus.DONE} means that the statement has finished
        executing successfully. {ctext SQLiteStatementHandle.step} should
        not be called again on this virtual machine without calling
        {docref SQLiteStatementHandle.reset}.

        If the SQL statement being executed returns any data, then
        {ctext SQLiteStatus.ROW} is returned for each time a row of data is
        ready for processing by the caller. The values can be accessed
        by using {ctext SQLiteInterface.column-*} method. Subsequent
        rows are retrieved by calling {ctext SQLiteStatementHandle.step}
        method.
    }
  }
  {method public {step}:SQLiteStatus
    {self.check-lock-out}
    {with self._lock-out? = true do
        {return {{SQLiteInterface}.step self._handle}}
    }
  }

  {doc-next
    {purpose
        Resets a prepared SQL statement.
    }
    {notes
        After this call {param stmt} is ready to be re-executed. Any
        SQL parameters that have values bound to them will retain
        their values on the subsequent execution.
    }
  }
  {method public {reset}:SQLiteStatus
    {self.check-lock-out}
    {if not self.open? then {return SQLiteStatus.OK}}
    {with self._lock-out? = true do
        {return {{SQLiteInterface}.reset self._handle}}
    }
  }
}

{define-class package SQLiteAttachInfo
  field package constant url:Url
  field package constant encryption-type:SQLiteEncryptionType
  field package constant key:#ByteArray
  {constructor package {default
                           url:Url,
                           encryption-type:SQLiteEncryptionType,
                           key:#ByteArray
                       }
    set self.url = url
    set self.encryption-type = encryption-type
    set self.key = key
  }
}

{doc-next
    {purpose
        An object representing a SQLite database connection.
    }
    {notes
        The connection will be closed when an applet is suspended,
        but all state will be re-installed when the applet is
        resumed.
    }
    {since 7.0}
}
{define-class public final SQLiteDatabaseHandle

  field private _sqlite3:LowSQLiteDatabaseHandle

  || Indicates that it is not safe to do any API call that changes the
  || database handle.  Used in this class and SQLiteInterface during
  || hooks, callbacks and handlers.
  || FIXME: really the changing of this field should be in this class
  || not SQLiteInterface and SQLiteInterface should take the Low handle
  || for all of the hooks, callbaks and handlers, but it was easier
  || to do it this way.
  field package _change-lock-out?:bool

  || Indicates that it is not safe to do any API call that closes the
  || database handle.  Used in this class during installed functions.
  field private _close-lock-out?:bool

  {define-proc private {throw-lock-out-error}:never-returns
    {throw
        {SQLiteException 
            SQLiteStatus.MISUSE,
            {hlmessage Can not call close the database or
                finalize or prepare new statements
                while executing a hook or callback.}
        }
    }
  }

  {method private inline {check-change-lock-out}:void
    {if self._change-lock-out? then
        {SQLiteDatabaseHandle.throw-lock-out-error}
    }
  }

  {method private inline {check-close-lock-out}:void
    {if self._change-lock-out? or self._close-lock-out? then
        {SQLiteDatabaseHandle.throw-lock-out-error}
    }
  }

  {doc-next
    {purpose
        A list of {docref SQLiteStatement}s created by this object that
        are not finalized.
    }
    {notes
        This list is used by {docref SQLiteDatabase} to finalize all
        the {ctext SQLiteStatement}s when {docref
        SQLiteDatabaseHandle.close} method is called.
    }
  }
  field constant private statements:{Array-of SQLiteStatementHandle}

  field private _busy-timeout:int

  || Saved and re-installed when the database is re-opened.
  field private busy-handler-callback:#SQLiteBusyHandlerProcType
  || This holds on to the callback that will be created in response to 
  || setting the busy handler callback for this object. This pointer is 
  || necessary to hold, otherwise the busy handler callback that is passed
  || to the SQLiteInterface could be garbage collected and hence result
  || in memory access violation.
  field private busy-handler-callback-ptr:SQLiteBusyHandlerPointerType =
    {uninitialized-value-for-type SQLiteBusyHandlerPointerType}

  
  || Saved and re-installed when the database is re-opened.
  field private update-callback:#SQLiteUpdateHookProcType
  || This holds on to the callback that will be created in response to 
  || setting the update callback for this object. This pointer is 
  || necessary to hold, otherwise the update callback that is passed
  || to the SQLiteInterface could be garbage collected and hence result
  || in memory access violation.
  field private update-callback-ptr:SQLiteUpdateCallbackPointerType =
    {uninitialized-value-for-type SQLiteUpdateCallbackPointerType}

  || Saved and re-installed when the database is re-opened.
  field private progress-callback:#SQLiteProgressHandlerProcType
  field private progress-callback-arg:int
  field private progress-callback-ptr:SQLiteProgressHandlerPointerType =
    {uninitialized-value-for-type SQLiteProgressHandlerPointerType}

  || Saved and re-installed when the database is re-opened.
  field private _authorizer:#SQLiteAuthorizerProcType
  field private _user-authorizer:#SQLiteAuthorizerProcType
  field private authorizer-ptr:SQLiteAuthorizerPointerType =
    {uninitialized-value-for-type SQLiteAuthorizerPointerType}
  field private _suppress-authorizer?:bool


  || Saved and re-installed when the database is re-opened.
  field private commit-callback:#SQLiteCommitHookProcType
  || This holds on to the callback that will be created in response to 
  || setting the commit callback for this object. This pointer is 
  || necessary to hold, otherwise the commit callback that is passed
  || to the SQLiteInterface could be garbage collected and hence result
  || in memory access violation.
  field private commit-callback-ptr:SQLiteCommitCallbackPointerType =
    {uninitialized-value-for-type SQLiteCommitCallbackPointerType}


  || Saved and re-installed when the database is re-opened.
  field private rollback-callback:#SQLiteRollbackHookProcType

  || This holds on to the callback that will be created in response to 
  || setting the rollback callback for this object. This pointer is 
  || necessary to hold, otherwise the rollback callback that is passed
  || to the SQLiteInterface could be garbage collected and hence result
  || in memory access violation.
  field private rollback-callback-ptr:SQLiteRollbackCallbackPointerType =
    {uninitialized-value-for-type SQLiteRollbackCallbackPointerType}

  || Note: these is null when the database is closed.  And when
  || the database is open, a registered proc will keep this
  || Object alive, which is required.
  field private suspend-proc:#{proc-type {}:void}
  field private exit-proc:#{proc-type {}:void}

  || Saved and re-installed when the database is re-opened.
  field private constant installed-functions:{Array-of FunctionSpec} =
    {new {Array-of FunctionSpec}}

  field private attached-databases:#{HashTable-of String, SQLiteAttachInfo}

  {doc-next
    {purpose
        If non-{ctext null}, this is the {docref Url} of the database to
        connect to. If null then the database will be a memory
        database.
    }
  }
  field constant public url:#Url

  field constant private error-if-missing?:bool
  field constant private read-only?:bool
  field constant private auto-vacuum?:bool
  field constant private page-size:int
  field private _encryption-type:SQLiteEncryptionType
  field private _key:#ByteArray

  {constructor public {default
                          u:#Url,
                          error-if-missing?:bool = false,
                          read-only?:bool = false,
                          auto-vacuum?:bool = false,
                          page-size:int = -1,
                          encryption-type:SQLiteEncryptionType =
                              SQLiteEncryptionType.none,
                          key:#ByteArray = null
                      }
    set self.url = u
    set self.statements = {{Array-of SQLiteStatementHandle}}
    set self._busy-timeout = (5s / 1ms) asa int
    set self.error-if-missing? = error-if-missing?
    set self.read-only? = read-only?
    set self.auto-vacuum? = auto-vacuum?
    set self.page-size = page-size
    set self._encryption-type = encryption-type
    set self._key = key
    {if-built-in
        {if not {process-privileged?} then
            {self.low-set-authorizer
                {proc
                    {operation:SQLiteOperation,
                     data1:#String,
                     data2:#String,
                     data3:#String,
                     data4:#String
                    }:SQLiteAuthorizerReturnCode
                    {return
                        {self.unprivileged-authorizer
                            operation, data1, data2, data3, data4
                        }
                    }
                }
            }
        }
    }
  }

{if-built-in
  {method private {unprivileged-authorizer
                      operation:SQLiteOperation,
                      data1:#String,
                      data2:#String,
                      data3:#String,
                      data4:#String
                  }:SQLiteAuthorizerReturnCode
    {switch operation 
     case SQLiteOperation.ATTACH do
        {return
            {if self._suppress-authorizer? then
                || FIXME: should we try to check the filename
                || that seems hard, so we just require use of
                || {attach}
                SQLiteAuthorizerReturnCode.DENY
             else
                SQLiteAuthorizerReturnCode.OK
            }
        }
     case SQLiteOperation.PRAGMA do
        || <database.>journal_size_limit, <database.>journal_mode 
        || are probably safe, but seem scary.
        {switch data1
         case "auto_vacuum", "page_size", "case_sensitive_like", ||""
            "count_changes", "encoding", "fullsync", ||""
            "incremental_vacuum", "legacy_file_format", ||""
            "full_column_names", "short_column_names", "synchronous",  ||""
            "database_list", "foreign_key_list",  ||""
            "index_info", "index_list", "table_info", ||""
            "integrity_check", "quick_check", "temp_store" ||""
         do
            || Those are allowed.
         else
            {if-non-null data1 then
                {if {SQLiteDatabaseHandle.match-pragma-with-name?
                        data1, "locking_mode"} or ||""
                    {SQLiteDatabaseHandle.match-pragma-with-name?
                        data1, "freelist_count"} or ||""
                    {SQLiteDatabaseHandle.match-pragma-with-name?
                        data1, "page_count"} or ||""
                    {SQLiteDatabaseHandle.match-pragma-with-name?
                        data1, "user_version"} or ||""
                    ({SQLiteDatabaseHandle.match-pragma-with-name?
                        data1, "schema_version"} and data2 == null) ||""
                 then
                    || Those are allowed.
                 else
                    {return SQLiteAuthorizerReturnCode.DENY}
                }
             else
                {return SQLiteAuthorizerReturnCode.DENY}
            }
        }
     else
        || other operations are allowed.
    }
    {if-non-null ua = self._user-authorizer then
        {return {ua operation, data1, data2, data3, data4}}
    }
    {return SQLiteAuthorizerReturnCode.OK}
  }

  {define-proc private {match-pragma-with-name? data1:String, name:String}:bool
    {return
        {data1.suffix? name} and
        (data1.size == name.size or
         {data1.find '.'} == ((data1.size - name.size) - 1))
    }
  }
}

  {doc-next
    {purpose
        Open the database this object represents.
    }
    {notes
        If the database is open then calling this method does nothing.
        
        This method is called lazily by most operations to open the
        database connection.
    }
  }
  {method public {open}:(SQLiteStatus, errmsg:#String)
    {if self._sqlite3 != 0 then {return SQLiteStatus.OK, null}}

    let filename:String =
        {if-non-null u = self.url then
            {if-non-null f = u.local-filename then
                {if-built-in
                    let psm:SecurityManagerInterface =
                        {get-process-security-manager}
                    {if self.read-only? then
                        {psm.check-read-local-file u}
                    else
                        {psm.check-write-local-file u}
                    }
                }
                f
             else
                {error {lmessage Invalid non-local database url '{value u}'.}}
            }
         else
            ":memory:" ||""
        }
|| This needs mxPathname to also be larger, and then this fixes things.
||--    {platform-switch
||--     case "win32" do
||--        {if filename.size >= 3 and filename[1] == ':' and filename[2] == '\\'
||--         then
||--            set filename = |"\\?\"| & filename
||--         elseif {filename.prefix? |"\\"|} and
||--            not {filename.prefix? |"\\?"|}
||--         then
||--            set filename = |"\\?\UNC\"| & {filename.tail 2}
||--        }
||--    }

    let status:SQLiteStatus
    let errmsg:#String
    set (status, self._sqlite3) = 
        {{SQLiteInterface}.open
            filename,
            fail-if-missing? = self.error-if-missing?,
            read-only? = self.read-only?
        }
    {if status != SQLiteStatus.OK then
        set errmsg = {{SQLiteInterface}.errmsg self}
        {{SQLiteInterface}.close self._sqlite3}
        set self._sqlite3 = 0
        {return status, errmsg}
    }
    set (status, errmsg) =
        {self.set-key self._encryption-type, self._key}
    {if status != SQLiteStatus.OK then
        {{SQLiteInterface}.close self._sqlite3}
        set self._sqlite3 = 0
        {return status, errmsg}
    }

    || Register procs to release resources (by closing database).
    || Database is opened lazily, so no need for resume proc.
    || - File databases can be closed on suspend    
    || - memory databases (or temp databases) would be lost

    let suspend-proc:{proc-type {}:void} =
        {proc {}:void
            || |#DEBUG#| {errput {message on SUSPEND in {value self} ({value {get-working-directory-url}.filename})}}
            {if self.close-on-suspend? then
                || |#DEBUG#| {errput {message ... can close}}
                {self.close}}
        }
    set self.suspend-proc = suspend-proc
    {register-suspend-proc suspend-proc}

    let exit-proc:{proc-type {}:void} =
        {proc {}:void
            || |#DEBUG#| {errput {message on EXIT in {value self} ({value {get-working-directory-url}.filename}) }}
            {self.close}
        }
    set self.exit-proc = exit-proc
    {register-exit-proc exit-proc}

    || Note: Authorizer won't see these, because we havn't installed it yet.
    {if not self.read-only? then
        {self.exec "PRAGMA encoding='UTF-8';PRAGMA synchronous=NORMAL"} ||""
        {if self.page-size != -1 then
            || Could fail with a non-power of 2 page-size or a too big one.
            let (status:SQLiteStatus, errmsg:#String) =
                {self.exec "PRAGMA page_size=" & self.page-size} ||""
            {if status != SQLiteStatus.OK then
                {return status, errmsg}
            }
        }
        {if self.auto-vacuum? then
            {self.exec "PRAGMA auto_vacuum=1"} ||""
        }
    }

    {if self._authorizer != null then
        let constant (status:SQLiteStatus, errmsg:#String) =
            {self.set-authorizer self._authorizer}
        {if status != SQLiteStatus.OK then
            {return status, errmsg}
        }
    }
    
    {if self._busy-timeout > 0 then
        let constant (status:SQLiteStatus, errmsg:#String) =
            {self.set-busy-timeout self._busy-timeout * 1ms}
        {if status != SQLiteStatus.OK then
            {return status, errmsg}
        }
    }

    {for f in self.installed-functions do
        let constant aggregate?:bool = (f.final-xfunc != null)
        let constant status:SQLiteStatus =
            {{SQLiteInterface}.create-function
                self._sqlite3, f.name, f.number-of-args, 
                {if not aggregate? then
                    f.xfunc
                 else
                    null
                },
                {if aggregate? then
                    f.xfunc
                 else
                    null
                },
                f.final-xfunc
            }
    
        {if status != SQLiteStatus.OK then
            set errmsg = {{SQLiteInterface}.errmsg self}
            {return status, errmsg}
        }
    }

    {if-non-null callback = self.busy-handler-callback then
        let constant (status:SQLiteStatus, errmsg:#String) =
            {self.set-busy-handler callback}
        {if status != SQLiteStatus.OK then
            {return status, errmsg}
        }
    }

    {if-non-null callback = self.update-callback then
        set self.update-hook = callback
    }
    {if-non-null callback = self.commit-callback then
        set self.commit-hook = callback
    }
    {if-non-null callback = self.rollback-callback then
        set self.rollback-hook = callback
    }
    {if-non-null callback = self.progress-callback then
        {self.set-progress-handler self.progress-callback-arg, callback}
    }
    {if-non-null attached-databases = self.attached-databases then
        {for ad key name in attached-databases do
            let constant (status:SQLiteStatus, errmsg:#String) =
                {self.attach
                    ad.url, name,
                    encryption-type = ad.encryption-type, key = ad.key
                }
            {if status != SQLiteStatus.OK then
                {return status, errmsg}
            }
        }
    }
    {return SQLiteStatus.OK, null}
  }

  {doc-next
    {purpose
        Closes the database connection.
    }
    {return-vals
        If successful, it returns {ctext SQLiteStatus.OK}. If there
        are prepared statements that have not been finalized, it will
        finalize them before attempting to close the
        database. Otherwise the error code will be returned.

        If the database is already closed {ctext SQLiteStatus.OK} is
        returned.
    }
  }
  {method public open {close}:(SQLiteStatus, errmsg:#String)
    {if self._sqlite3 == 0 then {return SQLiteStatus.OK, null}}
    {self.check-close-lock-out}

    let constant statements:{Array-of SQLiteStatementHandle} = self.statements
    {while statements.size > 0 do
        let constant handle:SQLiteStatementHandle = {statements.pop}
        || Ignore finalize errors.
        {self.finalize-statement handle}
        || |#DEBUG#| {errput {message SQLITE finalized {value stmt.sql}}}
    }
    let constant status:SQLiteStatus = {{SQLiteInterface}.close self.sqlite3}
    {if status == SQLiteStatus.OK then
        set self._sqlite3 = 0
        {unregister-suspend-proc {non-null self.suspend-proc}}
        set self.suspend-proc = null
        {unregister-exit-proc {non-null self.exit-proc}}
        set self.exit-proc = null
     else
        {return status, {{SQLiteInterface}.errmsg self}}
    }
    {return SQLiteStatus.OK, null}
  }
  
  {getter public final {open?}:bool
    {return self._sqlite3 != 0}
  }

  {doc-next
    {purpose
        The handle of the open SQLite database object.
    }
    {notes
        If the database is not open, calling this getter will attempt
        to open the database. If the attempt fails, an error will be thrown.
    }
  }
  {getter package {non-null-sqlite3}:LowSQLiteDatabaseHandle
    {self.open}
    {return self._sqlite3}
  }

  {doc-next
    {purpose
        The handle of the SQLite database object.
    }
    {notes
        If the database is not open the returned value will be 0 and
        no attempt will be made to open the database.
    }
  }
  {getter protected {sqlite3}:LowSQLiteDatabaseHandle
    {return self._sqlite3}
  }

  {getter private {close-on-suspend?}:bool
    || TODO: check also for TEMP tables
    {return
        || don't want to lose in-memory databases
        self.url != null
    }
  }


  {doc-next
    {purpose
        Notifies the {docref SQLiteDatabase} object that a {docref
        SQLiteStatement} was prepared.
    }
    {notes
        The default implementation appends {param stmt} in the {docref
        SQLiteDatabaseHandle.statements} list.
        
        This is called by {docref SQLiteStatement.prepare} method.
    }
  }
  {method private {note-statement-prepared handle:SQLiteStatementHandle}:void
    let constant statements:{Array-of SQLiteStatementHandle} = self.statements

    {if {statements.find handle} == -1 then
        {statements.append handle}
    }
  }

  {doc-next
    {purpose
        Notifies the {docref SQLiteDatabase} object that a {docref
        SQLiteStatement} was finalized.
    }
  }
  {method private {note-statement-finalized stmt:SQLiteStatementHandle}:void
    {if self.sqlite3 == 0 then {return}}
    let constant statements:{Array-of SQLiteStatementHandle} = self.statements

    {assert stmt._handle == 0}
    let constant index:int = {statements.find stmt}
    {if index != -1 then
        {statements.remove index}
    }
  }

  {getter public open {busy-handler}:#SQLiteBusyHandlerProcType
    {return self.busy-handler-callback}
  }

  {method public open {set-busy-handler
                          callback:#SQLiteBusyHandlerProcType
                      }:(SQLiteStatus, errmsg:#String)

    {if self.sqlite3 != 0 then
        let status:SQLiteStatus
        set (status, self.busy-handler-callback-ptr) =
            {{SQLiteInterface}.busy-handler
                self,
                callback
            }
        {if status != SQLiteStatus.OK then
            {return status, {{SQLiteInterface}.errmsg self}}
        }
    }
    set self.busy-handler-callback = callback
    set self._busy-timeout = 0
    {return SQLiteStatus.OK, null}
  }

  {getter public {busy-timeout}:Time
    {return self._busy-timeout * 1ms}
  }
  {method public {set-busy-timeout t:Time}:(SQLiteStatus, errmsg:#String)
    let timeout:int = (t / 1ms) asa int 
    {if self.sqlite3 != 0 then
        let constant status:SQLiteStatus =
            {{SQLiteInterface}.busy-timeout self.non-null-sqlite3, timeout}
        {if status != SQLiteStatus.OK then
            {return status, {{SQLiteInterface}.errmsg self}}
        }
    }
    set self._busy-timeout = timeout
    set self.busy-handler-callback = null
    set self.busy-handler-callback-ptr =
        {uninitialized-value-for-type SQLiteBusyHandlerPointerType}
    {return SQLiteStatus.OK, null}
  }

  {doc-next
    {purpose
        Registers a callback function on the database connection that
        will be invoked whenever a row is updated, inserted, or deleted.
    }
    {parameter callback,
        The callback procedure.

        The first argument is {ctext SQLiteOperation.INSERT},
        {ctext SQLiteOperation.DELETE} or {ctext
        SQLiteOperation.UPDATE}, depending on the operation that
        caused the callback to be invoked.

        The second and third arguments identify the database and the
        table name containing the effected row and the final callback
        argument is the {ctext ROWID} of the row. In case of an
        update, this is the {ctext ROWID} after the update takes
        place.
    }
    {details
        The {param callback} is not invoked when internal system
        tables are modified.

        See also {docref SQLiteDatabaseHandle.commit-hook} and {docref
        SQLiteDatabaseHandle.rollback-hook}.
    }
  }
  {setter public open {update-hook
                          callback:#SQLiteUpdateHookProcType
                      }:void

    set self.update-callback = callback
    {if self.sqlite3 != 0 then
        set self.update-callback-ptr =
            {{SQLiteInterface}.update-hook self, callback}
    }
  }

  {getter public open {update-hook}:#SQLiteUpdateHookProcType
    {return self.update-callback}
  }

  {doc-next
    {purpose
        Registers a callback function with the database connection that
        will be invoked whenever a new transaction is completed.
    }
    {parameter callback,
        The callback procedure.
    }
    {notes
        If {param callback} returns {ctext true} then the commit is
        converted into a rollback.
    }
  }
  {setter public open {commit-hook
                          callback:#SQLiteCommitHookProcType
                      }:void
    set self.commit-callback = callback
    {if self.sqlite3 != 0 then
        set self.commit-callback-ptr =
            {{SQLiteInterface}.commit-hook self, callback}
    }
  }

  {getter public open {commit-hook}:#SQLiteCommitHookProcType
    {return self.commit-callback}
  }

  {doc-next
    {purpose
        Registers a callback function with the database connection that
        will be invoked whenever a transaction is rolled back.
    }
    {parameter callback,
        The callback procedure.
    }
    {notes
        The {param callback} will be invoked if an explicit {ctext
        ROLLBACK} statement is executed, or an error or constraint
        causes an implicit rollback to occur. It will not be invoked
        if a transaction is automatically rolled back because the
        database connection is closed.
    }
  }
  {setter public open {rollback-hook
                          callback:#SQLiteRollbackHookProcType
                     }:void

    set self.rollback-callback = callback
    {if self.sqlite3 != 0 then
        set self.rollback-callback-ptr =
            {{SQLiteInterface}.rollback-hook
                self,
                callback
            }
    }
  }

  {getter public open {rollback-hook}:#SQLiteRollbackHookProcType
    {return self.rollback-callback}
  }

  {doc-next
    {purpose
        Set the progress handler that will get called periodically
        when executing a statement takes more than {param instruction-count}
        instructions.
    }
    {parameter instruction-count,
        Number of instructions that must be executed before calling
        {param callback}.
    }
    {parameter callback,
        The callback procedure.
    }
    {notes
        The {param callback} may not be invoked for all statements, if
        the statement takes less than {param instruction-count} instructions
        to complete.  If the {param callback} returns {ctext true}
        then the executing statement will be terminated.

        Providing a {ctext null} {param callback} will uninstall the
        progress handler.
    }
  }
  {method public {set-progress-handler
                     instruction-count:int,
                     callback:#SQLiteProgressHandlerProcType
                 }:void
    set self.progress-callback-arg = instruction-count
    set self.progress-callback = callback
    {if self.sqlite3 != 0 then
        set self.progress-callback-ptr =
            {{SQLiteInterface}.progress-handler
                self, instruction-count, callback}
    }
  }

  {doc-next
    {purpose
        Registers a callback function with the database connection that
        will be invoked whenever a statement is prepared.
    }
    {parameter callback,
        The callback procedure.
    }
    {notes
        The {param callback} can return {ctext SQLiteAuthorizerReturnCode.OK}
        to allow an statement to proceed,
        {ctext SQLiteAuthorizerReturnCode.DENY} to fail a statement,
        or when the operation is {ctext SQLiteOperation.READ},
        it can return {ctext SQLiteAuthorizerReturnCode.IGNORE} to
        disallow access to a particular table column.

        The first parameter to {param callback} is the {docref SQLiteOperation}         describing the operation being considered, and the next 4 arguments
        provide various information depending on the operation.
        The second argument is usually the name of the entity being operated
        on, and the third argument is the name of the other entity being
        operated on, if appropriate.  The fourth argument is usually the
        database name, and the fifth argument is the name of the inner-most
        trigger or view if there is one.

        Setting {param callback} to {ctext null} will uninstall any
        authorizer callback.
    }
  }
  {method public {set-authorizer
                     callback:#SQLiteAuthorizerProcType
                 }:(SQLiteStatus, errmsg:#String)
    {if-built-in
        {if {process-privileged?} then
            {return {self.low-set-authorizer callback}}
        else
            set self._user-authorizer = callback
        }
        {return SQLiteStatus.OK, null}
     else
        {return {self.low-set-authorizer callback}}
    }
  }

  {method private {low-set-authorizer
                      callback:#SQLiteAuthorizerProcType
                  }:(SQLiteStatus, errmsg:#String)
    {if self.sqlite3 != 0 then
        let status:SQLiteStatus
        set (status, self.authorizer-ptr) =
            {{SQLiteInterface}.set-authorizer
                self, callback}
        {if status != SQLiteStatus.OK then
            {return status, {{SQLiteInterface}.errmsg self}}
        }
    }
    set self._authorizer = callback
    {return SQLiteStatus.OK, null}
  }

  {getter public {authorizer}:#SQLiteAuthorizerProcType
    {return self._authorizer}
  }

  || Extend SQL functionality.
  {method private {find-installed-function
                     name:String,
                     number-of-args:int
                  }:int
    {for f key i in self.installed-functions do
        {if f.name == name and f.number-of-args == number-of-args then
            {return i}
        }
    }
    {return -1}
  }

  {doc-next
    {purpose
        Adds SQL function or redefines the behavior of an existing
        SQL function or an aggregate.
    }
    {parameter name,
        Name to use in SQL for the function.
    }
    {parameter number-of-args,
        Number of arguments that the function will take.
        If negative, then the the function can take any number of arguments.
        You can have multiple functions registered with the same name if
        they are installed with a different {param number-of-args}.
    }
    {parameter xfunc,
        For a scalar function this will be called with the appropriate
        number of arguments, of the types supplied by SQLite, and it
        should return the value to be used as the result in SQLite.

        For an aggregate function this will get a 'context' value as
        the first argument, and the first time that the aggregate
        function is called, it will be the {ctext initialized-value}
        of the type of the first argument to this function.  And the
        function should return a value for the 'context' that will be
        saved and passed in for the next item.
    }
    {parameter xfunc-final,
        If {param xfunc} is an aggregate function, then this parameter
        must be supplied to produce the final value.  The only parameter
        will be the 'context' value, and it should return the value to
        be used as the result in SQLite.
    }
    {notes
        If one of the functions throws an {docref Exception} then the
        {docref Exception.message} will be set as the error message, and
        the function will be marked as failing.  If the {docref Exception}
        is a {docref SQLiteException} then {docref SQLiteException.code}
        will be set as the error code, if the exception is not a 
        {docref SQLiteException}, then the error code will be
        {ctext SQLiteStatus.ERROR}.
    }
  }
  || TODO: should this take a default aggregate-context value instead
  || of us just using {uninitialized-value-for-type}?
  || FIXME: add support for sqlite3_get_auxdata()?  You can do that sort of
  || caching yourself fairly easily.
  {method public {install-function
                     name:String,
                     number-of-args:int,
                     xfunc:any,
                     final-xfunc:any = null
                 }:(SQLiteStatus, errmsg:#String)
    let constant type-of-xfunc:ProcType =
        {type-switch {type-of xfunc}
         case p:ProcType do
            p
         else
            {error {lmessage You must provide a function to 'install-function'}}
        }
    let constant aggregate?:bool = final-xfunc != null
    {if aggregate? then
        let constant type-of-final-xfunc:ProcType =
            {type-switch {type-of final-xfunc}
             case p:ProcType do
                p
             else
                {error {lmessage You must provide a function to 'install-function'}}
            }
        {if not (type-of-xfunc.num-args > 0 or
                 type-of-xfunc.takes-rest-args?) or
            not (type-of-final-xfunc.num-args > 0 or
                 type-of-final-xfunc.takes-rest-args?)
         then
            {error
                {lmessage You must provide a function that can take the
                    aggregate context value as the first argument to
                    'install-function'}}
        }
    }
    let aggregate-arg:int = {if aggregate? then 1 else 0}
    {if not ((number-of-args >= 0 and 
              (type-of-xfunc.num-args == number-of-args + aggregate-arg) or
              (type-of-xfunc.num-args < number-of-args + aggregate-arg and
               type-of-xfunc.takes-rest-args?)) or
             (number-of-args < 0 and type-of-xfunc.takes-rest-args?))
     then
        {error
            {lmessage You must provide a function that can take the right
                number of arguments to 'install-function'}}
    }
    let constant function:SQLiteFunctionProcType =
        {proc {context:SQLiteContextHandle,
               args:{Array-of SQLiteValueHandle}
              }:void
            {self.call-registered-function xfunc, context, args,
                aggregate? = aggregate?
            }
        }
    let constant final-function:#SQLiteFinalFunctionProcType =
        {if final-xfunc != null then
            {proc {context:SQLiteContextHandle}:void
                let old-close-lock-out?:bool = self._close-lock-out?
                set self._close-lock-out? = true
                {try
                    let func-type:ProcType = {type-of final-xfunc} asa ProcType
                    let retval:any =
                        {with-compiler-directives allow-any-calls? = true do
                            {final-xfunc
                                {self.get-aggregate-context-value
                                    context,
                                    default-value =
                                        {uninitialized-value-for-type
                                            {SQLiteDatabaseHandle.type-for-function-arg func-type, 0}
                                        }
                                }
                            }
                        }
                    {SQLiteDatabaseHandle.set-result context, retval}
                 catch ex:SQLiteException do
                    {{SQLiteInterface}.result-error context, ex.message}
                    {{SQLiteInterface}.result-error-code context, ex.code}
                 catch ex:Exception do
                    {{SQLiteInterface}.result-error context, ex.message}
                 finally
                    {self.set-aggregate-context-value context, null}
                    set self._close-lock-out? = old-close-lock-out?
                }
            }
         else
            null
        }

    let constant (status:SQLiteStatus, cdecl-f:SQLiteFunctionPointerType,
         cdecl-s:SQLiteFunctionPointerType,
         cdecl-ff:SQLiteFinalFunctionPointerType) =
        {{SQLiteInterface}.create-function
            self.non-null-sqlite3, name, number-of-args, 
            {if not aggregate? then
                function
             else
                null
            },
            {if aggregate? then
                function
             else
                null
            },
            final-function
        }
    
    {if status == SQLiteStatus.OK then
        let index:int =
            {self.find-installed-function name, number-of-args}
        let spec:FunctionSpec =
            {FunctionSpec
                name, number-of-args, function,
                {if aggregate? then cdecl-s else cdecl-f},
                final-xfunc = final-function,
                final-xfunc-ptr = cdecl-ff
            }
        {if index >= 0 then
            set self.installed-functions[index] = spec
         else
            {self.installed-functions.append spec}
        }
     else
        {return status, {{SQLiteInterface}.errmsg self}}
    }
    {return SQLiteStatus.OK, null}
  }

  {doc-next
    {purpose
        Uninstalls a previously installed function, installed with the
        same {param name} and {param number-of-args}, if any.
    }
    {parameter name,
        Name of the function to uninstall.
    }
    {parameter number-of-args,
        Number of arguments that function took.
    }
  }
  {method public {uninstall-function
                     name:String,
                     number-of-args:int
                 }:(SQLiteStatus, errmsg:#String)
    let constant index:int =
        {self.find-installed-function name, number-of-args}
    {if index == -1 or self._sqlite3 == 0 then
        || Should this be an error?
        {return SQLiteStatus.OK, null}
    }

    let constant status:SQLiteStatus =
        {{SQLiteInterface}.create-function
            self.sqlite3, name, number-of-args,
            null, null, null
        }

    {if status == SQLiteStatus.OK then
        {self.installed-functions.remove index}
     else
        {return status, {{SQLiteInterface}.errmsg self}}
    }
    {return SQLiteStatus.OK, null}
  }

  {define-proc private {curl-type-to-desired-type t:Type}:Type
    {return
        {switch t
         case String, StringInterface do
            String
         case float, double do
            double asa Type
         case int8, uint8, int16, uint16, int do
            int asa Type
         case uint32, uint64, int64 do
            int64 asa Type
         case ByteArray do
            ByteArray
         else
            NullType
        }
    }
  }

  {define-proc private {set-result context:SQLiteContextHandle, retval:any}:void
    let interface:SQLiteInterface = {SQLiteInterface}
    let ret-desired-type:Type =
        {SQLiteDatabaseHandle.curl-type-to-desired-type {type-of retval}}
    {switch ret-desired-type
     case String do
        {interface.result-text context, retval asa String}
     case double do
        {interface.result-double context, retval asa double}
     case int do
        {interface.result-int context, retval asa int}
     case int64 do
        {interface.result-int64 context, retval asa int64}
     case ByteArray do
        {interface.result-blob context, retval asa ByteArray}
     else
        {interface.result-null context}
    }
  }

  {define-proc private {type-for-function-arg
                           function-type:ProcType, arg-index:int
                       }:Type
    {return
        || If the function has a positional argument for that slot,
        || see if it wants a particular type.
        {if function-type.num-args > arg-index then
            {function-type.arg-type arg-index}
         || If rest args, see if that wants a particular type.
         elseif function-type.takes-rest-args? then
            {if-non-null rest-args-type = function-type.rest-args-type then
                rest-args-type
            else
                any
            }
         else
            NullType
        }
    }
  }

  {method private {call-registered-function
                      xfunc:any,
                      context:SQLiteContextHandle,
                      args:{Array-of SQLiteValueHandle},
                      aggregate?:bool = false
                  }:void
    let constant type-of-xfunc:ProcType =
        {type-switch {type-of xfunc}
         case p:ProcType do
            p
         else
            {error {lmessage You must provide a function to 'install-function'}}
        }
    let constant xfunc-args:Arguments = {Arguments}
    {if aggregate? then
        {xfunc-args.append
            {self.get-aggregate-context-value
                context,
                default-value =
                    {uninitialized-value-for-type
                        {SQLiteDatabaseHandle.type-for-function-arg
                            type-of-xfunc, 0}
                    }
            }
        }
    }
    let constant interface:SQLiteInterface = {SQLiteInterface}
    {for arg key arg-index in args do
        let desired-type:Type = NullType
        let real-type:Type = NullType
        let constant arg-type:Type =
            {SQLiteDatabaseHandle.type-for-function-arg
                type-of-xfunc, arg-index}
        set desired-type =
            {SQLiteDatabaseHandle.curl-type-to-desired-type arg-type}
        {if desired-type != NullType then
            set real-type = arg-type
        }
        || Ask the value what type it is.
        {if desired-type == NullType then
            set desired-type =
                {switch {interface.value-type arg}
                 case SQLiteDatatype.INTEGER do
                    let v:int64 = {interface.value-int64 arg}
                    {if v <= max-int and v >= min-int then
                        int asa Type
                     else
                        int64 asa Type
                    }
                 case SQLiteDatatype.REAL do
                    double asa Type
                 case SQLiteDatatype.TEXT do
                    String
                 case SQLiteDatatype.BLOB do
                    ByteArray
                 else
                    NullType
                }
        }
        {if real-type == NullType then
            set real-type = desired-type
        }
        || Get the value as desired type.
        {xfunc-args.append
            {switch desired-type
             case String do
                {interface.value-text arg} asa real-type
             case double do
                {interface.value-double arg} asa real-type
             case int do
                {interface.value-int arg} asa real-type
             case int64 do
                {interface.value-int64 arg} asa real-type
             case ByteArray do
                {interface.value-blob arg}
             else
                null
            }
        }
    }
    let old-close-lock-out?:bool = self._close-lock-out?
    set self._close-lock-out? = true
    {try
        let retval:any =
            {with-compiler-directives allow-any-calls? = true do
                {xfunc {splice xfunc-args}}
            }
        {if aggregate? then
            {self.set-aggregate-context-value context, retval}
         else
            {SQLiteDatabaseHandle.set-result context, retval}
        }
     catch ex:SQLiteException do
        {{SQLiteInterface}.result-error context, ex.message}
        {{SQLiteInterface}.result-error-code context, ex.code}
     catch ex:Exception do
        {{SQLiteInterface}.result-error context, ex.message}
     finally
        set self._close-lock-out? = old-close-lock-out?
    }
  }

  field constant private
    _aggregate-context-table:{HashTable-of int, any} =
    {new {HashTable-of int, any}}
  field private next-context-int:int = 0

  {method private {context-to-int context:SQLiteContextHandle}:int
    let constant interface:SQLiteInterface = {SQLiteInterface}
    let ret:int = {interface.get-aggregate-context-int context}
    {if ret == 0 then
        {inc self.next-context-int}
        set ret = self.next-context-int
        {interface.set-aggregate-context-int context, ret}
    }
    {return ret}
  }

  {method private {get-aggregate-context-value
                      context:SQLiteContextHandle,
                      default-value:any = null
                  }:any
    let (a:any, found?:bool) =
        {self._aggregate-context-table.get-if-exists
            {self.context-to-int context}
        }
    {return
        {if found? then a else default-value}
    }
  }

  {method private {set-aggregate-context-value
                      context:SQLiteContextHandle,
                      a:any
                  }:void
    {if a != null then
        set self._aggregate-context-table[{self.context-to-int context}] = a
     else
        {self._aggregate-context-table.remove
            {self.context-to-int context}, error-if-missing? = false
        }
    }
  }

  {method public {prepare-statement
                     sql:String,
                     handle:SQLiteStatementHandle
                 }:(tail:#String, SQLiteStatus, errmsg:#String)
    {self.check-change-lock-out}
    {if handle.open? then
        {return null, SQLiteStatus.MISUSE, 
            {lmessage Tried to prepare already prepared statement.}}
    }
    let (status:SQLiteStatus, lhandle:LowSQLiteStatementHandle, tail:#String) =
        {{SQLiteInterface}.prepare 
            self.non-null-sqlite3, sql
        }

    {if tail == "" then set tail = null}
    
    {if status != SQLiteStatus.OK then
        {return tail, status, {{SQLiteInterface}.errmsg self}}
    }

    || If we are here, the SQLiteInterface successfully compiled the
    || sql statement.
    set handle._handle = lhandle
    {self.note-statement-prepared handle}
    {return tail, status, null}
  }

  {method public {finalize-statement
                     handle:SQLiteStatementHandle
                 }:SQLiteStatus
    {self.check-change-lock-out}
    let status:SQLiteStatus = {handle.finalize}
    {if status == SQLiteStatus.OK then
        {self.note-statement-finalized handle}
    }
    {return status}
  }

  {doc-next
    {purpose
        Attach a new database under the supplied {param name}.
    }
    {parameter u,
        {docref Url} of the database to attach.
    }
    {parameter name,
        Name to use in subsequent SQL queries to access tables in the
        database in {param u}.
    }
    {parameter encryption-type,
        Type of encryption to use for an encrypted database.
    }
    {parameter key,
        Key to use for an encrypted database.
    }
  }
  {method public {attach
                     u:Url,
                     name:String,
                     encryption-type:SQLiteEncryptionType =
                         SQLiteEncryptionType.none,
                     key:#ByteArray = null
                 }:(status:SQLiteStatus, errmsg:#String)
    {self.check-change-lock-out}
    {if-built-in
        {{get-process-security-manager}.check-write-local-file u}
    }
    let filename:String =
        {if-non-null f = u.local-filename then
            f
         else
            {error {lmessage Invalid database url '{value u}'.}}
        }
    let (status:SQLiteStatus, errmsg:#String) =
        {self.exec
            "ATTACH '" & {SQLiteDatabaseHandle.sql-quote filename} &
            "' AS '" & {SQLiteDatabaseHandle.sql-quote name} &
            "' KEY " &
            {SQLiteDatabaseHandle.ByteArray-as-blob-string-interface
                {SQLiteInterface.make-key-bytearray encryption-type, key}
            } ||""
        }
    {if status == SQLiteStatus.OK then
        {if self.attached-databases == null then
            set self.attached-databases =
                {new {HashTable-of String, SQLiteAttachInfo}}
        }
        set self.attached-databases[name] =
            {SQLiteAttachInfo u, encryption-type, key}
    }
    {return status, errmsg}
  }
  {define-proc private {ByteArray-as-blob-string-interface
                           b:#ByteArray
                       }:StringBuf
    let s:StringBuf = {StringBuf "X'"}
    {if-non-null b then
        {for v in b do
            {s.append "0123456789ABCDEF"[{bit-srl v, 4}]} ||""
            {s.append "0123456789ABCDEF"[{bit-and v, 0xF}]} ||""
        }
    }
    {s.append '\''}
    {return s}
  }

  {method private {exec sql:String}:(status:SQLiteStatus, errmsg:#String)
    let (status:SQLiteStatus, errmsg:String) =
        {{SQLiteInterface}.exec self.non-null-sqlite3, sql}
    {return status, errmsg}
  }

 {doc-next
    {purpose
        Detach a previously attached database.
    }
    {parameter name,
        Name supplied when the database was attached.
    }
  }
  {method public {detach name:String}:(status:SQLiteStatus, errmsg:#String)
    {self.check-change-lock-out}
    {if-non-null attached-databases = self.attached-databases then
        {attached-databases.remove name, error-if-missing? = false}
    }
    {return
        {self.exec "DETACH '" & {SQLiteDatabaseHandle.sql-quote name} & "'"} ||""
    }
  }

  {define-proc private {sql-quote s:String}:String
    {return {s.replace-clone "'", "''"}}
  }

  {doc-next
    {purpose
        Set the encryption key for the main database.
    }
  }
  {method public {set-key
                     encryption-type:SQLiteEncryptionType,
                     key:#ByteArray
                 }:(SQLiteStatus, errmsg:#String)
    set self._encryption-type = encryption-type
    set self._key = key
    {if self._sqlite3 == 0 then
        {return SQLiteStatus.OK, null}
     else
        let status:SQLiteStatus =
            {{SQLiteInterface}.set-key self, encryption-type, key}
        {switch status
         case SQLiteStatus.OK do
            {return status, null}
         case SQLiteStatus.CURL-INTERNAL-MISSING-API do
            {return 
                SQLiteStatus.AUTH,
                {lmessage Authentication APIs are not available.}
            }
        else
            {return status, {{SQLiteInterface}.errmsg self}}
        }
    }
  }

}
